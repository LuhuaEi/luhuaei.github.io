<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-11-03 Sun 11:52 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>KNN算法预测CIFAR(01)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="luhuaei">

<meta name="google-site-verification" content="dVWCUwH8eYXavYgAUJtgmzwlXVIcYZeyvlUolZQVb2E" />
<link rel="stylesheet" type="text/css" href="/assets/css/style.css"/>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<div class="content-wrapper container">
   <div class="row"> <div class="col"> </div>   <div class="col-sm-6 col-md-8">
<div id="preamble" class="status">

<div class="">
    <a href="/"> Luhua.ei </a>
</div>
<ul class="">
  <li><a href="/about.html"> About Me </a> </li>
  <li><a href="https://github.com/luhuaei"> Github </a> </li>
  <li><a href="/archive.html"> Posts </a> </li>
</ul>
  <hr>
</div>
<div id="content">
<header>
<h1 class="title">KNN算法预测CIFAR(01)</h1>
</header><p>
根据KNN的原理，实现KNN模型，加深对KNN的理解。
</p>
<div id="outline-container-orgc09f51c" class="outline-2">
<h2 id="orgc09f51c">依赖加载</h2>
<div class="outline-text-2" id="text-orgc09f51c">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #859900;">import</span> numpy <span style="color: #859900;">as</span> np
<span style="color: #859900;">import</span> matplotlib.pyplot <span style="color: #859900;">as</span> plt
<span style="color: #859900;">from</span> collections <span style="color: #859900;">import</span> Counter
<span style="color: #859900;">import</span> pickle
<span style="color: #859900;">import</span> os

<span style="color: #405A61;"># </span><span style="color: #405A61;">&#35774;&#32622;&#40664;&#35748;&#30340;&#22270;&#29255;&#22823;&#23567;</span>
<span style="color: #6c71c4;">plt.rcParams</span>[<span style="color: #2aa198;">'figure.figsize'</span>] = (10.0, 8.0)
<span style="color: #6c71c4;">plt.rcParams</span>[<span style="color: #2aa198;">'image.cmap'</span>] = <span style="color: #2aa198;">'gray'</span>
<span style="color: #6c71c4;">plt.rcParams</span>[<span style="color: #2aa198;">'image.interpolation'</span>] = <span style="color: #2aa198;">'nearest'</span>

<span style="color: #859900;">def</span> <span style="color: #268bd2;">relative_error</span>(x, y):
    <span style="color: #35a69c;">'''&#35745;&#31639;x&#19982;y&#20043;&#38388;&#30340;&#30456;&#23545;&#35823;&#24046;&#65292;x&#19982;y&#21487;&#20197;&#26159;&#25968;&#20540;&#65292;&#20063;&#21487;&#20197;&#26159;&#25968;&#32452;'''</span>
    <span style="color: #859900;">return</span> np.<span style="color: #268bd2;">max</span>(np.<span style="color: #268bd2;">abs</span>(x - y) / (np.maximum(1e-8, np.<span style="color: #268bd2;">abs</span>(x) + np.<span style="color: #268bd2;">abs</span>(y))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd062da" class="outline-2">
<h2 id="orgdd062da">数据加载</h2>
<div class="outline-text-2" id="text-orgdd062da">
<p>
由于CIFAR默认的格式为二进制格式，不能使用常规的文件读取进行解码。
<code>np.concatenate()</code> 类似于 <code>np.c_ or np.r_</code> 用来合并数据。
</p>
</div>
<div id="outline-container-org1b6bed5" class="outline-3">
<h3 id="org1b6bed5">数据加载函数</h3>
<div class="outline-text-3" id="text-org1b6bed5">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">unpickle</span>(file_name):
    <span style="color: #35a69c;">'''&#35299;&#30721;&#25968;&#25454;'''</span>
    <span style="color: #859900;">with</span> <span style="color: #268bd2;">open</span>(file_name, <span style="color: #2aa198;">'rb'</span>) <span style="color: #859900;">as</span> f:
        <span style="color: #6c71c4;">d</span> = pickle.load(f, encoding=<span style="color: #2aa198;">'bytes'</span>)
    <span style="color: #859900;">return</span> d


<span style="color: #859900;">def</span> <span style="color: #268bd2;">load_data_batch</span>(file_name):
    <span style="color: #35a69c;">'''The CIFAR DATA is a 10000x3072 numpy array of uint8s. Each row of the array</span>
<span style="color: #35a69c;">    stores a 32x32 colour image. The first 1024 entries contain the red channel</span>
<span style="color: #35a69c;">    values, the next 1024 the green, and the final 1024 the blue. The image is</span>
<span style="color: #35a69c;">    stored in row-major order, so that the first 32 entries of the array are the</span>
<span style="color: #35a69c;">    red channel values of the first row of the image. &#27599;&#19968;&#20010;&#22270;&#29255;&#37117;&#20855;&#26377;3&#23618;&#65292;&#20998;&#21035;</span>
<span style="color: #35a69c;">    &#20195;&#34920;RGB&#12290;&#32780;&#25968;&#32452;&#20013;&#30340;&#27599;&#19968;&#34892;&#20648;&#23384;&#19968;&#20010;&#22270;&#29255;&#65292;&#20854;&#20013;&#21069;1024&#21508;&#20540;&#20195;&#34920;&#22270;&#29255;&#30340;&#32418;&#33394;&#23618;&#65292;&#32780;&#25509;</span>
<span style="color: #35a69c;">    &#30528;&#20026;&#32511;&#33394;&#20540;&#65292;&#26368;&#21518;1024&#20010;&#20540;&#20026;&#34013;&#33394;&#12290;&#22240;&#27492;&#21487;&#20197;&#23558;&#22270;&#29255;&#37325;&#35774;&#25104;(3, 32, 32)&#65292;&#20877;&#32463;&#36807;&#35013;&#32622;</span>
<span style="color: #35a69c;">    &#25104;(32, 32, 3)&#23601;&#26159;&#25105;&#20204;&#24120;&#35265;&#30340;&#23485; X &#39640; X &#28145;&#24230;&#12290;</span>

<span style="color: #35a69c;">    labels is a list of 10000 numbers in the range 0-9. The number at index i</span>
<span style="color: #35a69c;">    indicates the label of the ith image in the array data.</span>
<span style="color: #35a69c;">    '''</span>
    <span style="color: #6c71c4;">d</span> = unpickle(file_name)
    <span style="color: #859900;">print</span>(d.keys())
    <span style="color: #6c71c4;">X</span> = d[b<span style="color: #2aa198;">'data'</span>]
    <span style="color: #6c71c4;">Y</span> = d[b<span style="color: #2aa198;">'labels'</span>]
    <span style="color: #6c71c4;">X</span> = X.reshape(10000, 3, 32, 32).transpose(0, 2, 3, 1).astype(<span style="color: #2aa198;">'float'</span>)
    <span style="color: #6c71c4;">Y</span> = np.array(Y)
    <span style="color: #859900;">return</span> X, Y


<span style="color: #859900;">def</span> <span style="color: #268bd2;">load_CIFAR_data</span>(CIFAR_path):
    <span style="color: #35a69c;">'''&#21152;&#36733;CIFAR&#25968;&#25454;&#65292;&#24182;&#23558;&#23567;&#25209;&#37327;&#30340;&#25968;&#25454;&#21512;&#24182;&#22312;&#19968;&#36215;&#12290;'''</span>
    <span style="color: #6c71c4;">xs</span> = []
    <span style="color: #6c71c4;">ys</span> = []
    <span style="color: #859900;">for</span> b <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(1, 6):
        <span style="color: #6c71c4;">f</span> = os.path.join(CIFAR_path, <span style="color: #2aa198;">'data_batch_%d'</span> % b)
        <span style="color: #6c71c4;">X</span>, <span style="color: #6c71c4;">Y</span> = load_data_batch(f)
        xs.append(X)
        ys.append(Y)
    <span style="color: #6c71c4;">Xtr</span> = np.concatenate(xs)
    <span style="color: #6c71c4;">Ytr</span> = np.concatenate(ys)
    <span style="color: #859900;">del</span> X, Y
    <span style="color: #6c71c4;">f</span> = os.path.join(CIFAR_path, <span style="color: #2aa198;">'test_batch'</span>)
    <span style="color: #6c71c4;">Xte</span>, <span style="color: #6c71c4;">Yte</span> = load_data_batch(f)
    <span style="color: #859900;">return</span> Xtr, Ytr, Xte, Yte


<span style="color: #859900;">def</span> <span style="color: #268bd2;">get_CIFAR_data</span>(num_training=49000, num_validation=1000, num_test=10000,
                   subtract_mean=<span style="color: #d33682;">True</span>):
    <span style="color: #35a69c;">'''</span>
<span style="color: #35a69c;">    &#25972;&#20010;CIFAR&#20849;&#26377;60000&#24352;&#22270;&#29255;&#65292;&#20854;&#20013;50000&#20316;&#20026;&#35757;&#32451;&#38598;&#65292;10000&#20316;&#20026;&#27979;&#35797;&#38598;&#12290;&#23545;&#21152;&#36733;&#30340;&#25968;&#25454;</span>
<span style="color: #35a69c;">    &#36827;&#34892;&#39044;&#22788;&#29702;&#25805;&#20316;&#65292;&#24182;&#36820;&#22238;&#23383;&#20856;&#24418;&#24335;&#12290;</span>
<span style="color: #35a69c;">    '''</span>
    <span style="color: #6c71c4;">cifar_dir</span> = <span style="color: #2aa198;">"/home/luhuaei/Data/cifar-10-batches-py/"</span>
    <span style="color: #6c71c4;">X_train</span>, <span style="color: #6c71c4;">Y_train</span>, <span style="color: #6c71c4;">X_test</span>, <span style="color: #6c71c4;">Y_test</span> = load_CIFAR_data(cifar_dir)

    <span style="color: #6c71c4;">xtrain</span> = X_train[:num_training]
    <span style="color: #6c71c4;">ytrain</span> = Y_train[:num_training]
    <span style="color: #6c71c4;">xtest</span> = X_test[:num_test]
    <span style="color: #6c71c4;">ytest</span> = Y_test[:num_test]
    <span style="color: #6c71c4;">xvalidation</span> = X_train[num_training:num_training + num_validation]
    <span style="color: #6c71c4;">yvalidation</span> = Y_train[num_training:num_training + num_validation]

    <span style="color: #859900;">if</span> subtract_mean:
        <span style="color: #6c71c4;">mean_image</span> = np.mean(xtrain, axis=0)
        <span style="color: #6c71c4;">xtrain</span> -= mean_image
        <span style="color: #6c71c4;">xvalidation</span> -= mean_image
        <span style="color: #6c71c4;">xtest</span> -= mean_image

        <span style="color: #6c71c4;">xtrain</span> = xtrain.transpose(0, 3, 1, 2).copy()
        <span style="color: #6c71c4;">xtest</span> = xtest.transpose(0, 3, 1, 2).copy()
        <span style="color: #6c71c4;">xvalidation</span> = xvalidation.transpose(0, 3, 1, 2).copy()

    <span style="color: #859900;">return</span> {
        <span style="color: #2aa198;">'x_train'</span>: xtrain, <span style="color: #2aa198;">'y_train'</span>: ytrain,
        <span style="color: #2aa198;">'x_validation'</span>: xvalidation, <span style="color: #2aa198;">'y_validation'</span>: yvalidation,
        <span style="color: #2aa198;">'x_test'</span>: xtest, <span style="color: #2aa198;">'y_test'</span>: ytest
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-orge56965f" class="outline-3">
<h3 id="orge56965f">加载数据</h3>
<div class="outline-text-3" id="text-orge56965f">
<p>
将数据集变成一个2维的矩阵。选取前面的5000作为训练集，1000作为验证集，1000作为测
试集。一些模型需要用到2维的数据形式。 <code>np.prod()</code> 为将元素累积。
</p>
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #6c71c4;">DATA</span> = get_CIFAR_data()
<span style="color: #6c71c4;">X_train</span> = DATA[<span style="color: #2aa198;">'x_train'</span>]
<span style="color: #6c71c4;">Y_train</span> = DATA[<span style="color: #2aa198;">'y_train'</span>]
<span style="color: #6c71c4;">X_test</span> = DATA[<span style="color: #2aa198;">'x_test'</span>]
<span style="color: #6c71c4;">Y_test</span> = DATA[<span style="color: #2aa198;">'y_test'</span>]
<span style="color: #6c71c4;">X_vali</span> = DATA[<span style="color: #2aa198;">'x_validation'</span>]
<span style="color: #6c71c4;">Y_vali</span> = DATA[<span style="color: #2aa198;">'y_validation'</span>]
<span style="color: #6c71c4;">X_train2d</span> = X_train.reshape(X_train.shape[0], np.prod(X_train.shape[1:]))
<span style="color: #6c71c4;">X_test2d</span> = X_test.reshape(X_test.shape[0], np.prod(X_test.shape[1:]))
<span style="color: #6c71c4;">X_vali2d</span> = X_vali.reshape(X_vali.shape[0], -1)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf66311b" class="outline-2">
<h2 id="orgf66311b">可视化数据</h2>
<div class="outline-text-2" id="text-orgf66311b">
<p>
<code>np.flatnonzero()</code> 将函数变平，并返回非零元素的索引。
</p>
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #6c71c4;">classes</span> = [<span style="color: #2aa198;">'plane'</span>, <span style="color: #2aa198;">'car'</span>, <span style="color: #2aa198;">'bird'</span>, <span style="color: #2aa198;">'cat'</span>, <span style="color: #2aa198;">'deer'</span>, <span style="color: #2aa198;">'dog'</span>, <span style="color: #2aa198;">'frog'</span>, <span style="color: #2aa198;">'horse'</span>, <span style="color: #2aa198;">'ship'</span>, <span style="color: #2aa198;">'truck'</span>]
<span style="color: #6c71c4;">num_classes</span> = <span style="color: #268bd2;">len</span>(classes)
<span style="color: #6c71c4;">sample_per_class</span> = 7
<span style="color: #859900;">for</span> y_index, cls <span style="color: #859900;">in</span> <span style="color: #268bd2;">enumerate</span>(classes):
    <span style="color: #405A61;"># </span><span style="color: #405A61;">&#36820;&#22238;index&#23545;&#24212;&#30340;&#31867;&#30340;&#25968;&#25454;&#65292;&#24182;&#21033;&#29992;np.flatnonzero()&#21464;&#24179;&#12290;</span>
    <span style="color: #6c71c4;">idxs</span> = np.flatnonzero(Y_train == y_index)
    <span style="color: #405A61;"># </span><span style="color: #405A61;">&#19981;&#25918;&#22238;&#25277;&#21462;&#25351;&#23450;&#20010;&#25968;&#26679;&#26412;&#65292;</span>
    <span style="color: #6c71c4;">idxs</span> = np.random.choice(idxs, sample_per_class, replace=<span style="color: #d33682;">False</span>)
    <span style="color: #859900;">for</span> i, idx <span style="color: #859900;">in</span> <span style="color: #268bd2;">enumerate</span>(idxs):
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#36825;&#37324;&#22270;&#29255;&#23637;&#31034;&#25104;7x10&#65292;&#35745;&#31639;&#22270;&#29255;&#20986;&#29616;&#30340;&#20301;&#32622;</span>
        <span style="color: #405A61;"># </span><span style="color: #405A61;">i * num_classes&#35745;&#31639;&#34892;&#25968;&#65292;y_index + 1&#35745;&#31639;&#21015;&#25968;</span>
        <span style="color: #6c71c4;">img_index</span> = i * num_classes + y_index + 1
        plt.subplot(sample_per_class, num_classes, img_index)
        plt.imshow(X_train[idx].astype(<span style="color: #2aa198;">'uint8'</span>))
        plt.axis(<span style="color: #2aa198;">'off'</span>)
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#35774;&#32622;&#22270;&#29255;&#30340;&#31867;&#21517;</span>
        <span style="color: #859900;">if</span> i == 0:
            plt.title(cls, color=<span style="color: #2aa198;">'green'</span>)
plt.show()
</pre>
</div>


<figure>
<img src="./images/cifar-data-on-knn-630170.png" alt="cifar-data-on-knn-630170.png">

</figure>
</div>
</div>

<div id="outline-container-orged412a8" class="outline-2">
<h2 id="orged412a8">K最近邻</h2>
<div class="outline-text-2" id="text-orged412a8">
</div>
<div id="outline-container-org92634ff" class="outline-3">
<h3 id="org92634ff">近邻算法</h3>
<div class="outline-text-3" id="text-org92634ff">
<p>
利用近邻算法对图片进行分类，由于图片一般具有三个channael，这里是利用两个图片进行
相减后取绝对值(L1)或者是相减后取平方在开方，对结果矩阵元素进行相加，得到两者之间
的距离。
</p>
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #859900;">class</span> <span style="color: #b58900;">NearesNeighbor</span>():
    <span style="color: #859900;">def</span> <span style="color: #268bd2;">__init__</span>(<span style="color: #859900;">self</span>, method=<span style="color: #2aa198;">"L1"</span>):
        <span style="color: #859900;">self</span>.method = method

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">train</span>(<span style="color: #859900;">self</span>, x_train, y_train):
        <span style="color: #859900;">self</span>.x_train = x_train
        <span style="color: #859900;">self</span>.y_train = y_train

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">predict</span>(<span style="color: #859900;">self</span>, x_pred):
        <span style="color: #6c71c4;">out_num</span> = x_pred.shape[0]
        <span style="color: #6c71c4;">out</span> = np.zeros(out_num, dtype=<span style="color: #859900;">self</span>.y_train.dtype)
        <span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(out_num):
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#25152;&#26377;&#35757;&#32451;&#26679;&#26412;&#37117;&#23545;&#24403;&#21069;&#30340;&#26679;&#26412;&#30697;&#38453;&#30456;&#20943;&#65292;&#24182;&#23545;&#32467;&#26524;&#27599;&#19968;&#21015;(axis=1)&#32047;&#21152;</span>
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#24471;&#21040;&#19968;&#20010;&#20108;&#32500;&#30340;&#30697;&#38453;(x_train_num, 1)</span>
            <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">"L1"</span>:
                <span style="color: #6c71c4;">distance</span> = np.<span style="color: #268bd2;">sum</span>(np.<span style="color: #268bd2;">abs</span>(<span style="color: #859900;">self</span>.x_train - x_pred[i, :]), axis=1)
            <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">"L2"</span>:
                <span style="color: #6c71c4;">distance</span> = np.sqrt(np.<span style="color: #268bd2;">sum</span>(np.square(<span style="color: #859900;">self</span>.x_train - x_pred[i, :]), axis=1))
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#23547;&#25214;&#26368;&#23567;&#36317;&#31163;&#30340;&#20301;&#32622;</span>
            <span style="color: #6c71c4;">min_index</span> = np.argmin(distance)
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#23558;&#24403;&#21069;&#30340;&#27979;&#35797;&#26679;&#26412;&#26631;&#35760;&#20026;&#26368;&#23567;&#36317;&#31163;&#23545;&#24212;&#30340;&#35757;&#32451;&#26679;&#26412;&#26631;&#31614;</span>
            <span style="color: #6c71c4;">out</span>[i] = <span style="color: #859900;">self</span>.y_train[min_index]
            <span style="color: #859900;">print</span>(i)
        <span style="color: #859900;">return</span> out
</pre>
</div>
</div>
</div>
<div id="outline-container-org3194088" class="outline-3">
<h3 id="org3194088">k近邻算法</h3>
<div class="outline-text-3" id="text-org3194088">
<blockquote>
<p>
The idea is very simple: instead of finding the single closest image in the
training set, we will find the top <b>k</b> closest images, and have them vote on the
label of the test image.
</p>
</blockquote>
<p>
从直觉上，选择的类越多，分类器受异常值的影响就越少。
</p>
</div>
</div>
<div id="outline-container-orgfbdf741" class="outline-3">
<h3 id="orgfbdf741">如何选择k？</h3>
<div class="outline-text-3" id="text-orgfbdf741">
<p>
在机器学习上，对于一些无法确定的参数，称为超参数(hyperparameters)。不能使用测试
集数据来改进超参数的，这会产生过拟合(overfit)，测试集应该只用于最后最后一步。
</p>

<blockquote>
<p>
Evaluate on the test set only a single time, at the very end.
</p>
</blockquote>

<p>
正确的调节参数的做法，应该为将数据分为测试集(test set)，以及训练集(train set)，
其中训练集又可以分出一部分数据为验证集(validation set)。使用验证集进行调参，得到
最终模型后，再用于测试集。
</p>

<p>
对于小数据集来说，分割出来的验证集与训练集数据量都很小，可以使用交叉验证方法
(cross-validation)。对于一个5折叠(fold)的交叉验证来说，将整个训练集等分为5份，使
用其中4份作为训练，1份作为验证集。
</p>
</div>
</div>

<div id="outline-container-orgba823c8" class="outline-3">
<h3 id="orgba823c8">Cross Validation</h3>
<div class="outline-text-3" id="text-orgba823c8">
<p>
将数据进行切割，返回一个列表，在python中，两个列表进行相加求值为将两个列表进行合
并。
</p>
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">cross_validation</span>(Xtr, Ytr, ks, folds, classifier):
    <span style="color: #6c71c4;">xtrf</span> = np.split(Xtr, folds)
    <span style="color: #6c71c4;">ytrf</span> = np.split(Ytr, folds)
    <span style="color: #6c71c4;">num_split</span> = Xtr.shape[0] / folds

    <span style="color: #6c71c4;">k_acc</span> = {}

    <span style="color: #859900;">for</span> ik, k <span style="color: #859900;">in</span> <span style="color: #268bd2;">enumerate</span>(ks):
        <span style="color: #6c71c4;">acc</span> = np.zeros(folds, dtype=np.<span style="color: #268bd2;">float</span>)
        <span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(folds):
            <span style="color: #6c71c4;">train</span> = np.concatenate((xtrf[:i] + xtrf[i+1:]))
            <span style="color: #6c71c4;">label</span> = np.concatenate((ytrf[:i] + ytrf[i+1:]))
            classifier.train(train, label)
            <span style="color: #6c71c4;">pred</span> = classifier.predict(xtrf[i], k)
            <span style="color: #6c71c4;">acc</span>[i] = np.mean(pred == ytrf[i])
        <span style="color: #6c71c4;">k_acc</span>[k] = acc
    <span style="color: #859900;">return</span> k_acc
</pre>
</div>
</div>
</div>
<div id="outline-container-org003297c" class="outline-3">
<h3 id="org003297c">算法实现</h3>
<div class="outline-text-3" id="text-org003297c">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #859900;">class</span> <span style="color: #b58900;">KNearesNeighbor</span>():
    <span style="color: #859900;">def</span> <span style="color: #268bd2;">__init__</span>(<span style="color: #859900;">self</span>, method=<span style="color: #2aa198;">'L2'</span>, loop_way=0):
        <span style="color: #859900;">self</span>.method = method
        <span style="color: #859900;">self</span>.loop_way = loop_way

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">train</span>(<span style="color: #859900;">self</span>, x_train, y_train):
        <span style="color: #859900;">self</span>.x_train = x_train
        <span style="color: #859900;">self</span>.y_train = y_train

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">predict</span>(<span style="color: #859900;">self</span>, x_pred, k):
        <span style="color: #859900;">self</span>.k = k
        <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.loop_way == 0:
            <span style="color: #6c71c4;">distance</span> = <span style="color: #859900;">self</span>.predict_no_loop(x_pred)
        <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.loop_way == 1:
            <span style="color: #6c71c4;">distance</span> = <span style="color: #859900;">self</span>.predict_one_loop(x_pred)
        <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.loop_way == 2:
            <span style="color: #6c71c4;">distance</span> = <span style="color: #859900;">self</span>.predict_two_loop(x_pred)
        <span style="color: #859900;">return</span> <span style="color: #859900;">self</span>.predict_label(distance)

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">predict_no_loop</span>(<span style="color: #859900;">self</span>, x_pred):
        <span style="color: #35a69c;">'''x_pred &#20026;&#38656;&#35201;&#39044;&#27979;&#30340;X&#65292;&#36820;&#22238;&#36317;&#31163;&#30697;&#38453;'''</span>
        <span style="color: #6c71c4;">xth</span>, <span style="color: #6c71c4;">xtw</span> = <span style="color: #859900;">self</span>.x_train.shape
        <span style="color: #6c71c4;">xph</span>, <span style="color: #6c71c4;">xpw</span> = x_pred.shape
        <span style="color: #6c71c4;">distance</span> = np.zeros((xph, xth))
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#36825;&#37324;&#21033;&#29992;numpy&#20013;&#24403;&#19968;&#20010;&#30697;&#38453;&#20943;&#21435;&#19968;&#20010;&#25968;&#32452;&#25110;&#32773;&#19968;&#20010;&#25968;&#20540;&#20943;&#21435;&#19968;&#20010;&#25968;&#32452;&#26102;&#65292;&#25968;&#32452;</span>
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#20013;&#27599;&#19968;&#20010;&#20540;&#37117;&#20250;&#34987;&#24212;&#29992;&#65292;&#22914;(5, 1) - (2, 1)&#34920;&#31034;&#25104;5&#20010;&#25968;&#20540;&#20943;&#21435;&#19968;&#20010;2&#32500;&#30340;&#25968;&#20540;&#65292;</span>
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#23558;&#20250;&#24471;&#21040;(5, 2)&#65292;&#22312;numpy&#20013;&#20250;&#23558;(2, 1)&#35013;&#32622;&#25104;(1, 2)&#65292;&#20174;&#32780;(5, 1) - (1, 2)&#24471;&#21040;&#19968;&#20010;5x2&#30340;&#30697;&#38453;&#65292;</span>
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#22914;&#26524;&#19968;&#20010;&#30697;&#38453;&#26159;&#26174;&#24335;&#25351;&#23450;&#20026;(5,1)&#21478;&#19968;&#20010;&#26174;&#24335;&#25351;&#23450;&#20026;(2, 1)&#30456;&#21152;&#23558;&#20250;&#20986;&#38169;</span>
        <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">'L1'</span>:
            <span style="color: #6c71c4;">distance</span> = np.<span style="color: #268bd2;">abs</span>(np.<span style="color: #268bd2;">sum</span>(x_pred, axis=1).reshape(xph, 1)
                              - np.<span style="color: #268bd2;">sum</span>(<span style="color: #859900;">self</span>.x_train, axis=1).reshape(1, xth))
        <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">'L2'</span>:
            <span style="color: #6c71c4;">distance</span> = np.sqrt(np.<span style="color: #268bd2;">sum</span>(x_pred**2, axis=1).reshape(xph, 1)
                               + np.<span style="color: #268bd2;">sum</span>(<span style="color: #859900;">self</span>.x_train**2, axis=1).reshape(1, xth) <span style="color: #405A61;"># </span><span style="color: #405A61;">&#36825;&#37324;&#35201;&#20040;&#19981;&#35201;reshape(xth, -1)&#65292;&#35201;&#20040;&#25351;&#23450;&#20026;(1, xth)&#21542;&#21017;&#20986;&#38169;</span>
                               - 2 * x_pred.dot(<span style="color: #859900;">self</span>.x_train.T))
        <span style="color: #859900;">return</span> distance

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">predict_one_loop</span>(<span style="color: #859900;">self</span>, x_pred):
        <span style="color: #35a69c;">'''x_pred &#20026;&#38656;&#35201;&#39044;&#27979;&#30340;X&#65292;&#36820;&#22238;&#36317;&#31163;&#30697;&#38453;'''</span>
        <span style="color: #6c71c4;">xph</span> = x_pred.shape[0]
        <span style="color: #405A61;"># </span><span style="color: #405A61;">&#35757;&#32451;&#38598;&#30340;&#26679;&#26412;&#20010;&#25968;&#65292;&#36825;&#37324;&#22240;&#20026;&#25972;&#20010;&#35757;&#32451;&#38598;&#26679;&#26412;&#37117;&#23545;&#27979;&#35797;&#38598;&#20013;&#30340;&#27599;&#19968;&#20010;&#22270;&#29255;&#36941;&#21382;</span>
        <span style="color: #6c71c4;">xth</span> = <span style="color: #859900;">self</span>.x_train.shape[0]
        <span style="color: #6c71c4;">distance</span> = np.zeros((xph, xth))
        <span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(xph):
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#25152;&#26377;&#35757;&#32451;&#26679;&#26412;&#37117;&#23545;&#24403;&#21069;&#30340;&#26679;&#26412;&#30697;&#38453;&#30456;&#20943;&#65292;&#24182;&#23545;&#32467;&#26524;&#27599;&#19968;&#21015;(axis=1)&#32047;&#21152;</span>
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#24471;&#21040;&#19968;&#20010;&#20108;&#32500;&#30340;&#30697;&#38453;(num, 1)</span>
            <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">"L1"</span>:
                <span style="color: #6c71c4;">distance</span>[i] = np.<span style="color: #268bd2;">sum</span>(np.<span style="color: #268bd2;">abs</span>(<span style="color: #859900;">self</span>.x_train - x_pred[i]), axis=1)
            <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">"L2"</span>:
                <span style="color: #6c71c4;">distance</span>[i] = np.sqrt(np.<span style="color: #268bd2;">sum</span>(np.square(<span style="color: #859900;">self</span>.x_train - x_pred[i]), axis=1))
        <span style="color: #859900;">return</span> distance

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">predict_two_loop</span>(<span style="color: #859900;">self</span>, x_pred):
        <span style="color: #35a69c;">'''x_pred &#20026;&#38656;&#35201;&#39044;&#27979;&#30340;X&#65292;&#36820;&#22238;&#36317;&#31163;&#30697;&#38453;'''</span>
        <span style="color: #6c71c4;">xth</span>, <span style="color: #6c71c4;">xtw</span> = <span style="color: #859900;">self</span>.x_train.shape
        <span style="color: #6c71c4;">xph</span>, <span style="color: #6c71c4;">xpw</span> = x_pred.shape
        <span style="color: #6c71c4;">distance</span> = np.zeros((xph, xth))
        <span style="color: #859900;">for</span> y <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(xph):
            <span style="color: #859900;">for</span> x <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(xth):
                <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">'L1'</span>:
                    <span style="color: #6c71c4;">distance</span>[y, x] = np.<span style="color: #268bd2;">sum</span>(np.<span style="color: #268bd2;">abs</span>(<span style="color: #859900;">self</span>.x_train[x] - x_pred[y]))
                <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.method == <span style="color: #2aa198;">'L2'</span>:
                    <span style="color: #6c71c4;">distance</span>[y, x] = np.sqrt(np.<span style="color: #268bd2;">sum</span>(np.square(<span style="color: #859900;">self</span>.x_train[x] - x_pred[y])))
        <span style="color: #859900;">return</span> distance

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">predict_label</span>(<span style="color: #859900;">self</span>, distance):
        <span style="color: #6c71c4;">out_num</span> = distance.shape[0]
        <span style="color: #6c71c4;">out</span> = np.zeros(out_num)
        <span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> <span style="color: #268bd2;">range</span>(out_num):
            <span style="color: #6c71c4;">top_k_index</span> = np.argsort(distance[i])[:<span style="color: #859900;">self</span>.k]
            <span style="color: #6c71c4;">top_k_label</span> = <span style="color: #859900;">self</span>.y_train[top_k_index]
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#20174;&#20960;&#20010;&#26631;&#31614;&#20013;&#36873;&#25321;&#26368;&#22810;&#25237;&#31080;(&#20986;&#29616;&#26368;&#22810;)&#30340;&#26631;&#31614;</span>
            <span style="color: #6c71c4;">vote</span> = Counter(top_k_label)
            <span style="color: #405A61;"># </span><span style="color: #405A61;">&#36820;&#22238;&#19968;&#20010;&#21015;&#34920;&#65292;&#21015;&#34920;&#20013;&#20026;&#20803;&#32452;&#65292;&#20803;&#32452;&#31532;&#19968;&#20010;&#20803;&#32032;&#20026;&#26631;&#31614;&#65292;&#31532;&#20108;&#20010;&#20026;&#20986;&#29616;&#30340;&#27425;&#25968;</span>
            <span style="color: #6c71c4;">count</span> = vote.most_common()
            <span style="color: #6c71c4;">out</span>[i] = count[0][0]
        <span style="color: #859900;">return</span> out
</pre>
</div>
</div>
</div>
<div id="outline-container-orge3c7b6b" class="outline-3">
<h3 id="orge3c7b6b">优缺点</h3>
<div class="outline-text-3" id="text-orge3c7b6b">
</div>
<div id="outline-container-org89d5396" class="outline-4">
<h4 id="org89d5396">优点</h4>
<div class="outline-text-4" id="text-org89d5396">
<p>
容易实现，简单理解。更适用于二维的数据。
</p>
</div>
</div>
<div id="outline-container-org20db0b5" class="outline-4">
<h4 id="org20db0b5">缺点</h4>
<div class="outline-text-4" id="text-org20db0b5">
<p>
计算量大，耗时长，每测试一个样本，都需要遍历整个训练集。
</p>
</div>
</div>
</div>
<div id="outline-container-org99c1d38" class="outline-3">
<h3 id="org99c1d38">测试数据</h3>
<div class="outline-text-3" id="text-org99c1d38">
</div>
<div id="outline-container-org3933f64" class="outline-4">
<h4 id="org3933f64">NN与KNN</h4>
<div class="outline-text-4" id="text-org3933f64">
<p>
不使用循环速度真的提升很多。
</p>
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #6c71c4;">nn</span> = NearesNeighbor(<span style="color: #2aa198;">"L2"</span>)
nn.train(X_train2d, Y_train)
<span style="color: #6c71c4;">nn_pred</span> = nn.predict(X_test2d)
<span style="color: #6c71c4;">nn_accurary</span> = np.mean(nn_pred == Y_test)

<span style="color: #6c71c4;">knn</span> = KNearesNeighbor(method=<span style="color: #2aa198;">'L2'</span>, loop_way=0)
knn.train(X_train2d, Y_train)
<span style="color: #6c71c4;">knn_pred</span> = knn.predict(X_test2d, k=10)
<span style="color: #6c71c4;">knn_accurary</span> = np.mean(knn_pred == Y_test)
<span style="color: #859900;">print</span>(<span style="color: #2aa198;">"NN: %.2f, KNN: %.2f"</span> %(nn_accurary, knn_accurary))
</pre>
</div>

<p>
NN: 0.27, KNN: 0.29
</p>
</div>
</div>
</div>

<div id="outline-container-orgb9c270e" class="outline-3">
<h3 id="orgb9c270e">使用交叉验证选择最优的k</h3>
<div class="outline-text-3" id="text-orgb9c270e">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #6c71c4;">num_folds</span> = 5
<span style="color: #6c71c4;">k_choices</span> = [1, 3, 5, 7, 10, 25, 50, 100]

<span style="color: #6c71c4;">knn</span> = KNearesNeighbor()
<span style="color: #6c71c4;">kacc</span> = cross_validation(X_train2d, Y_train, k_choices, num_folds, knn)
</pre>
</div>
</div>
</div>
<div id="outline-container-org75a142c" class="outline-3">
<h3 id="org75a142c">准确率可视化</h3>
<div class="outline-text-3" id="text-org75a142c">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #859900;">for</span> k <span style="color: #859900;">in</span> k_choices:
    <span style="color: #6c71c4;">acc</span> = kacc[k]
    plt.scatter([k] * <span style="color: #268bd2;">len</span>(acc), acc) <span style="color: #405A61;"># </span><span style="color: #405A61;">&#22266;&#23450;x&#65292;&#25551;&#32472;acc</span>

<span style="color: #405A61;"># </span><span style="color: #405A61;">&#35745;&#31639;&#27599;&#19968;&#20010;k&#23545;&#24212;&#30340;folds&#30340;&#24179;&#22343;&#20540;&#19982;&#26631;&#20934;&#24046;</span>
<span style="color: #6c71c4;">acc_mean</span> = [np.mean(v) <span style="color: #859900;">for</span> k, v <span style="color: #859900;">in</span> <span style="color: #268bd2;">sorted</span>(kacc.items())]
<span style="color: #6c71c4;">acc_std</span> = [np.std(v) <span style="color: #859900;">for</span> k, v <span style="color: #859900;">in</span> <span style="color: #268bd2;">sorted</span>(kacc.items())]
plt.errorbar(k_choices, acc_mean, yerr=acc_std)
plt.title(<span style="color: #2aa198;">'Cross Validation of k'</span>)
plt.xlabel(<span style="color: #2aa198;">'k'</span>)
plt.ylabel(<span style="color: #2aa198;">'accurary'</span>)
plt.show()
</pre>
</div>

<p>
<img src="./images/cifar-data-on-knn-397684.png" alt="cifar-data-on-knn-397684.png">
从上面的交叉验证中，可以寻找最高准确率对应的k值，即为最优的k=10。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer">
      <!-- Footer Definition -->
   </footer>

  <!-- Google Analytics Js --><!-- Disqua JS -->
</div>

</div>
<div class="col"></div></div>
</div>
</body>
</html>

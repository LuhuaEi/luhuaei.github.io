<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-01-05 Sun 22:27 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Vue.js 学习笔记</title>
<meta name="generator" content="Org mode">
<meta name="author" content="luhuaei">

<meta name="google-site-verification" content="dVWCUwH8eYXavYgAUJtgmzwlXVIcYZeyvlUolZQVb2E" />
<link rel="stylesheet" type="text/css" href="/assets/css/style.css"/>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<div class="content-wrapper container">
   <div class="row"> <div class="col"> </div>   <div class="col-sm-6 col-md-8"> 
<div id="preamble" class="status">

<div class="">
    <a href="/"> Luhua.ei </a>
</div>
<ul class="">
  <li><a href="/about.html"> About Me </a> </li>
  <li><a href="https://github.com/luhuaei"> Github </a> </li>
  <li><a href="/archive.html"> Posts </a> </li>
</ul>
  <hr>
</div>
<div id="content">
<header>
<h1 class="title">Vue.js 学习笔记</h1>
</header><p>
最近在学习 <code>Vue.js</code> ,在这里记录其中的一些坑.
</p>

<p>
关于 <code>Vue.js</code> 基本情况可以参考大佬的<a href="https://manateelazycat.github.io/web/2019/07/14/vue-tooltips.html">Vue.js实践小技巧</a>
</p>

<ol class="org-ol">
<li>数据或者对象中值改变,界面的数据不进行渲染.参考<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">官方文档</a></li>

<li><p>
怎样创建一个递归的组件,应用场景: 比如一个树状结构的展示列表. 也有一些评论场景
使用树状结构进行展示回复.
</p>

<pre class="example">
&lt;template&gt;
    &lt;div&gt;
        &lt;tree :user="next_user" :value="next_value"&gt;&lt;/tree&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
 export default {
     name: "tree",
     props: {
         user: String,
         value: Number,
     },
     data() {
         return {
             next_user: "",
             next_value: "",
         }
     }
 }
&lt;/script&gt;
</pre>
<p>
递归的关键点在于为一个组件使用 <code>name</code>  标记, 并在自身模板中引用本身.注意设定
结束判断条件,否则会出现递归溢出错误.
</p></li>

<li>在默认中引用全局函数并不需要加上 <code>this</code> 指针, 同样在模板中使用全局变量可以直
接写成 <code>$store.state.global_value</code> 的形式. 不同经过使用 <code>methods</code> 包装一层.</li>

<li><p>
过滤器用起来很方便, 可以在组件中定义局部过滤器,也可以使用 <code>Vue</code> 定义全局过滤
器.
</p>
<pre class="example">
&lt;!-- 局部过滤器 --&gt;
&lt;script&gt;
 export default {
     name: "test",
     filters: {
         odd: function(arr) {
             var result = [];
             arr.map((e) =&gt; {
                 if (e % 2 != 0) result.push(e);
             });
             return result;
         }
     }
 }

&lt;!-- 全局过滤器 --&gt;
Vue.filter("even", (arr) =&gt; {
     var result = [];
     arr.map((e) =&gt; {
         if (e % 2 == 0) result.push(e);
     });
     return result;
 });
&lt;/script&gt;
</pre></li>

<li>在使用 <code>WebSocket</code> 中需要不断的从服务器端过去信息,需要前端不断的渲染, 可以使
用 <code>watch</code> 监听执行流, 达到同步执行的效果. 比如一共需要按顺序执行几个程序, 其中每一个
程序在执行过程中会不断返回信息, 可以使用一个变量作为令牌, 然后用 <code>watch</code> 监听
变化，从而切换执行的程序。</li>

<li>不该使用箭头函数
<ol class="org-ol">
<li>不应该使用箭头函数来定义 method 函数</li>
<li>不应该对 data 属性使用箭头函数</li>
<li>不应该使用箭头函数来定义 watcher 函数</li>
<li>不应该使用箭头函数来定义计算属性函数</li>
</ol></li>

<li>keep-alive 组件的使用，这个组件可以让你页面进行缓存，当切换路由的时候，可以保
留原来页面的渲染数据不变。比如，当一个用户在等待一个加载的时候，这是他可能感
到不耐烦，切换到其他的页面，当他再次切换回来，可以保持进度条，或者已经渲染的
数据不被刷新，或者重新计算渲染。</li>
</ol>
</div>
<div id="postamble" class="status">
<footer class="footer">
      <!-- Footer Definition -->
   </footer>

  <!-- Google Analytics Js --><!-- Disqua JS --> 
</div>

</div>
<div class="col"></div></div>
</div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-04-21 Tue 22:47 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Vue.js 学习笔记</title>
<meta name="generator" content="Org mode">
<meta name="author" content="luhuaei">

<meta name="google-site-verification" content="dVWCUwH8eYXavYgAUJtgmzwlXVIcYZeyvlUolZQVb2E" />
<link rel="stylesheet" type="text/css" href="/assets/css/style.css"/>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<div class="content-wrapper container">
   <div class="row"> <div class="col"> </div>   <div class="col-sm-6 col-md-8">
<div id="preamble" class="status">

<div class="">
    <a href="/"> Luhua.ei </a>
</div>
<ul class="">
  <li><a href="/about.html"> About Me </a> </li>
  <li><a href="https://github.com/luhuaei"> Github </a> </li>
  <li><a href="/archive.html"> Posts </a> </li>
</ul>
  <hr>
</div>
<div id="content">
<header>
<h1 class="title">Vue.js 学习笔记</h1>
</header><p>
最近在学习 <code>Vue.js</code> ,在这里记录其中的一些坑.
</p>

<p>
关于 <code>Vue.js</code> 基本情况可以参考大佬的<a href="https://manateelazycat.github.io/web/2019/07/14/vue-tooltips.html">Vue.js实践小技巧</a>
</p>

<ol class="org-ol">
<li>数据或者对象中值改变,界面的数据不进行渲染.这个vue中不能响应结构中变化，但是在
官方文档中也给出了，对于一些操作是可以感知的，如push, pop这种。</li>

<li><p>
怎样创建一个递归的组件,应用场景: 比如一个树状结构的展示列表. 也有一些评论场景
使用树状结构进行展示回复.
</p>

<pre class="example">
&lt;template&gt;
    &lt;div&gt;
        &lt;tree :user="next_user" :value="next_value"&gt;&lt;/tree&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
 export default {
     name: "tree",
     props: {
         user: String,
         value: Number,
     },
     data() {
         return {
             next_user: "",
             next_value: "",
         }
     }
 }
&lt;/script&gt;
</pre>
<p>
递归的关键点在于为一个组件使用 <code>name</code>  标记, 并在自身模板中引用本身.注意设定
结束判断条件,否则会出现递归溢出错误.
</p></li>

<li>在模板中引用全局函数并不需要加上 <code>this</code> 指针, 同样在模板中使用全局变量可以直
接写成 <code>$store.state.global_value</code> 的形式. 不同经过使用 <code>methods</code> 包装一层.</li>

<li><p>
过滤器用起来很方便, 可以在组件中定义局部过滤器,也可以使用 <code>Vue</code> 定义全局过滤
器.
</p>
<pre class="example">
&lt;!-- 局部过滤器 --&gt;
&lt;script&gt;
 export default {
     name: "test",
     filters: {
         odd: function(arr) {
             let result = [];
             arr.map((e) =&gt; {
                 if (e % 2 != 0) result.push(e);
             });
             return result;
         }
     }
 }

&lt;!-- 全局过滤器 --&gt;
Vue.filter("even", (arr) =&gt; {
     let result = [];
     arr.map((e) =&gt; {
         if (e % 2 == 0) result.push(e);
     });
     return result;
 });
&lt;/script&gt;
</pre></li>

<li>不该使用箭头函数
<ol class="org-ol">
<li>不应该使用箭头函数来定义 method 函数</li>
<li>不应该对 data 属性使用箭头函数</li>
<li>不应该使用箭头函数来定义 watcher 函数</li>
<li>不应该使用箭头函数来定义计算属性函数</li>
</ol></li>

<li>keep-alive 组件的使用，这个组件可以让你页面进行缓存，当切换路由的时候，可以保
留原来页面的渲染数据不变。比如，当一个用户在等待一个加载的时候，这是他可能感
到不耐烦，切换到其他的页面，当他再次切换回来，可以保持进度条，或者已经渲染的
数据不被刷新，或者重新计算渲染。原理是通过将原来的页面进行缓存，当再次切换回
来的时候，优先从以缓存的队列中选取。</li>

<li>store 管理， <code>mutation</code> 接收参数必须只能两个，超出的都无法获取；第二个参数推荐传
递的是一个对象，来接收更多的信息。</li>

<li>slot 插槽, 用于组件层次的复用, 可以通过 <code>slot</code> 来自定义布局. 关于插槽, 通常将
使用具有插槽的组件(子组件)的组件(父组件). 子组件可以通过 <code>插槽prop</code> 来实现与
父组件之间的数据传递.</li>

<li>动态组件, 适用于多标签页面, 加上 <code>&lt;keep-alive&gt;</code> 可以保存原有的状态,而不会自
动更新,从而导致重新加载.</li>

<li>在多层次组件中，我比较喜欢将各个子组件的业务逻辑都集中到一个组件上(原始节点
组件)，而通过prop或者自定义事件来传递数据，这样就可以仅仅需要维护一个业务逻
辑的组件，而后面的子组件都可以将页面与数据脱离。对于多层次组件来说，使用
prop和自定义事件就需要层层传递，使用 v-on="$licenster" 可以跨中间组件传递事
件。</li>
</ol>
</div>
<div id="postamble" class="status">
<footer class="footer">
      <!-- Footer Definition -->
   </footer>

  <!-- Google Analytics Js --><!-- Disqua JS -->
</div>

</div>
<div class="col"></div></div>
</div>
</body>
</html>
